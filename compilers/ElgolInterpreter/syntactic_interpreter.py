import ply.yacc as yacc

from lexical_interpreter import ElgolLexer


class ElgolParser:
    """
    A parser for the Elgol programming language using PLY (Python Lex-Yacc).

    This class takes tokens generated by ElgolLexer and attempts to build an
    Abstract Syntax Tree (AST) based on the defined Elgol grammar. It handles
    syntax error reporting and propagation.

    Attributes:
        lexer_instance (ElgolLexer): An instance of the lexer.
        tokens (list): The list of token names, inherited from the lexer.
        parser (yacc.LRParser): The PLY parser instance.
        syntax_error_count (int): Counter for syntax errors encountered during parsing.
    """

    start = "program"

    def __init__(self):
        """Initializes the ElgolParser, creating lexer and parser instances."""
        self.lexer_instance = ElgolLexer()
        self.tokens = self.lexer_instance.tokens
        self.parser = yacc.yacc(module=self, start="program", debug=True, outputdir=".")
        self.syntax_error_count = 0

    def _find_first_function_call_in_expr(self, node):
        """
        Recursively finds the first 'function_call' node within an expression AST fragment.

        Used to check for invalid function calls in 'elgio' assignments.

        Args:
            node: The AST node or fragment to search within.

        Returns:
            tuple or None: The 'function_call' AST node if found, otherwise None.
        """
        if not isinstance(node, (tuple, list)) or not node:
            return None
        if isinstance(node, list):
            for item_in_list in node:
                found = self._find_first_function_call_in_expr(item_in_list)
                if found:
                    return found
            return None
        node_type = node[0]
        if node_type == "function_call":
            return node
        for part in node[1:]:
            found = self._find_first_function_call_in_expr(part)
            if found:
                return found
        return None

    def p_program(self, p):
        """program : component_list"""
        p[0] = ("program", p[1] if isinstance(p[1], list) else [])

    def p_component_list(self, p):
        """component_list : component_list component
        | component
        | empty"""
        if len(p) == 2:
            if p.slice[1].type == "empty":
                p[0] = []
            else:
                if p[1] is None:
                    p[0] = None
                else:
                    p[0] = [p[1]]
        else:
            if p[1] is None or p[2] is None:
                p[0] = None
            else:
                p[0] = p[1] + [p[2]]

    def p_component(self, p):
        """component : function_definition
        | main_block"""
        p[0] = p[1]

    def p_function_definition(self, p):
        """function_definition : type_specifier FUNCTION_NAME LPAREN parameters_opt RPAREN DOT block"""
        if p[7] is None:
            p[0] = None
        else:
            p[0] = (
                "function_definition",
                {"type": p[1], "name": p[2], "params": p[4], "body": p[7]},
            )

    def p_parameters_opt(self, p):
        """parameters_opt : parameter_list
        | empty"""
        if p.slice[1].type == "empty":
            p[0] = []
        else:
            p[0] = p[1]

    def p_parameter_list(self, p):
        """parameter_list : parameter_list COMMA parameter
        | parameter"""
        if len(p) == 2:
            if p[1] is None:
                p[0] = None
            else:
                p[0] = [p[1]]
        else:
            if p[1] is None or p[3] is None:
                p[0] = None
            else:
                p[0] = p[1] + [p[3]]

    def p_parameter(self, p):
        """parameter : type_specifier IDENTIFIER"""
        p[0] = ("parameter", {"type": p[1], "name": p[2]})

    def p_type_specifier(self, p):
        """type_specifier : INTEIRO"""
        p[0] = p[1]

    def p_main_block(self, p):
        """main_block : block"""
        p[0] = p[1]

    def p_block(self, p):
        """block : INICIO DOT statement_list_opt FIM DOT"""
        if p[3] is None:
            p[0] = None
        else:
            p[0] = ("block", p[3])

    def p_statement_list_opt(self, p):
        """statement_list_opt : statement_list
        | empty"""
        if p.slice[1].type == "empty":
            p[0] = []
        else:
            p[0] = p[1]

    def p_statement_list(self, p):
        """statement_list : statement_list statement
        | statement"""
        if len(p) == 2:
            if p[1] is None:
                p[0] = None
            else:
                p[0] = [p[1]]
        else:
            if p[1] is None or p[2] is None:
                p[0] = None
            else:
                p[0] = p[1] + [p[2]]

    def p_variable_declaration(self, p):
        """variable_declaration : type_specifier IDENTIFIER"""
        p[0] = ("variable_declaration", {"type": p[1], "name": p[2]})

    def p_statement(self, p):
        """statement : variable_declaration DOT
        | expression_statement DOT
        | if_statement
        | while_statement"""
        if p[1] is None:
            p[0] = None
        else:
            p[0] = p[1]

    def p_expression_statement(self, p):
        """expression_statement : expression"""
        p[0] = p[1]

    def p_if_statement(self, p):
        """if_statement : SE expression DOT ENTAO DOT block senao_opt"""
        is_else_present_and_failed = (
            len(p.slice) > 7 and p.slice[7].type != "empty" and p[7] is None
        )

        if p[2] is None or p[6] is None or is_else_present_and_failed:
            p[0] = None
        else:
            p[0] = (
                "if_statement",
                {"condition": p[2], "then_block": p[6], "else_block": p[7]},
            )

    def p_senao_opt(self, p):
        """senao_opt : SENAO DOT block
        | empty"""
        if len(p) == 4:
            p[0] = p[3]
        else:
            p[0] = None

    def p_while_statement(self, p):
        """while_statement : ENQUANTO expression DOT block"""
        if p[2] is None or p[4] is None:
            p[0] = None
        else:
            p[0] = ("while_statement", {"condition": p[2], "body": p[4]})

    def p_lvalue(self, p):
        """lvalue : IDENTIFIER
        | ELGIO"""
        p[0] = ("lvalue", p[1])

    def p_expression_assign(self, p):
        """expression : lvalue EQUALS expression"""
        lvalue_node = p[1]
        lvalue_name = lvalue_node[1]
        rhs_expression_node = p[3]

        if rhs_expression_node is None:
            p[0] = None
            return

        if lvalue_name == "elgio":
            offending_func_call_details = self._find_first_function_call_in_expr(
                rhs_expression_node
            )
            if offending_func_call_details:
                func_name_in_expr = offending_func_call_details[1]
                error_line = p.lineno(1)

                print(
                    f"Syntax Error: Line {error_line}. Reason: Function '{func_name_in_expr}' cannot be used as an operand in an assignment to 'elgio'."
                )

                self.syntax_error_count += 1
                p[0] = None
                return

        p[0] = ("assign", lvalue_name, rhs_expression_node)

    def p_expression_binop(self, p):
        """expression : expression PLUS expression
        | expression MINUS expression
        | expression TIMES expression
        | expression DIVIDE expression
        | expression MAIOR expression
        | expression MENOR expression
        | expression IGUAL expression
        | expression DIFERENTE expression"""
        if p[1] is None or p[3] is None:
            p[0] = None
        else:
            p[0] = (p[2], p[1], p[3])

    def p_expression_comp_unary(self, p):
        """expression : COMP expression"""
        if p[2] is None:
            p[0] = None
        else:
            p[0] = ("unary_operator_comp", p[2])

    def p_expression_group(self, p):
        """expression : LPAREN expression RPAREN"""
        p[0] = p[2]

    def p_expression_integer(self, p):
        """expression : INTEGER"""
        p[0] = ("integer_literal", p[1])

    def p_expression_zero(self, p):
        """expression : ZERO"""
        p[0] = ("integer_literal", 0)

    def p_expression_identifier_like(self, p):
        """expression : IDENTIFIER
        | ELGIO"""
        p[0] = ("identifier_lookup", p[1])

    def p_expression_function_call(self, p):
        """expression : FUNCTION_NAME LPAREN argument_list_opt RPAREN"""
        p[0] = ("function_call", p[1], p[3])

    def p_argument_list_opt(self, p):
        """argument_list_opt : argument_list
        | empty"""
        if p.slice[1].type == "empty":
            p[0] = []
        else:
            p[0] = p[1]

    def p_argument_list(self, p):
        """argument_list : argument_list COMMA expression
        | expression"""
        if len(p) == 2:
            if p[1] is None:
                p[0] = None
            else:
                p[0] = [p[1]]
        else:
            if p[1] is None or p[3] is None:
                p[0] = None
            else:
                p[0] = p[1] + [p[3]]

    def p_empty(self, p):
        """empty :"""
        p[0] = None

    def p_error(self, p):
        """
        Error handling rule for syntax errors.

        This function is called by PLY when a syntax error is encountered,
        or when a rule explicitly sets p[0] = None and PLY cannot recover.
        It prints an error message, including line number and the unexpected token.
        It may also print additional information if the error involves an operator
        missing an operand.
        """
        if p:

            coluna_str = ""
            try:
                if (
                    hasattr(p, "lexer")
                    and p.lexer
                    and hasattr(p.lexer, "lexdata")
                    and hasattr(self.lexer_instance, "_find_column")
                    and callable(self.lexer_instance._find_column)
                ):
                    coluna = self.lexer_instance._find_column(p.lexer.lexdata, p)
                    coluna_str = f", Column {coluna}"
            except Exception:
                pass

            print(
                f"Syntax error on line {p.lineno}{coluna_str}: unexpected symbol '{p.value}'"
            )

            if hasattr(p, "lexer") and p.lexer and hasattr(p.lexer, "last_token"):
                last = p.lexer.last_token
                if (
                    last
                    and hasattr(last, "type")
                    and last.type in ("PLUS", "MINUS", "TIMES", "DIVIDE")
                ):
                    print(
                        f"    Additional Info: operator '{last.value}' on line {last.lineno} might be missing a valid right-hand operand."
                    )

        else:
            print("Syntax error: unexpected end of file")

    def parse(self, data: str):
        """
        Parses the input string using the defined grammar and lexer.

        Args:
            data (str): The Elgol source code string to parse.

        Returns:
            The AST generated by the parser, or None if parsing fails
            at the top level or if syntax errors prevent AST construction.
        """
        self.syntax_error_count = 0
        self.lexer_instance.input(data)  # Ensure lexer is reset with new data
        return self.parser.parse(data, lexer=self.lexer_instance.lexer, tracking=True)
